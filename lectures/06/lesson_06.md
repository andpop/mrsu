# Цель - перевести написанное ранее консольное приложение на языке PHP на другую платформу. Теперь работать игра должна внутри веб-браузера
Для этого нам придется перейти на другой язык программирования, так как внутри браузера могут работать только программы на языке JavaScript.

## Определяемся с общей архитектурой приложения, продумываем процесс переноса приложения на другую платформу
При создании консольного PHP-приложения нужно было спроектировать его так, чтобы бизнес-логика и работа с данными были отделены от представления данных. Это должно помочь при миграции на другую платформу:
* Бизнес-логика остается той же. Логика игры и алгоритм остаются теми же. Ходы делаются так же, победитель определяется так же.
И в PHP, и в JavaScript используется императивный процедурный подход, то есть у нас должно получиться оставить те же модули и функции.
* Высокоуровневые методы для сохранения и извлечения данных остаются теми же, но сам механизм работы с данными меняется. Мы с реляционной СУБД SQLite переходим на нереляционную СУБД IndexedDB. Каркас остается, реализация полностью меняется.
* Полностью меняется пользовательский интерфейс. В консольном приложении мы могли только вводить с клавиатуры данные и отображать символьные строки на экране. Теперь в нашем распоряжении возможности браузера, можно реализовать красивый и функциональный графический интерфейс (различные элементы управления, работа с мышью и т.д.). Эту часть придется полностью переделать.

Рассматривать особенности и возможности языка JavaScript будем по тому же плану, что и PHP.
## Выясняем специфику языка программирования JavaScript

### Как написать и запустить простейший скрипт (Hello, world)?
JavaScript код может выполняться внутри браузера или непосредственно в операционной системе (платформа Node.js). Мы пока будем говорить только о JavaScript внутри браузера.
Что вообще может браузер, из каких частей он состоит? 
Внутри браузера работают два движка, отвечающих за отображение содержимого веб-страниц и выполнение содержащегося в них JavaScript-кода:
* Движок рендеринга (render engine). Он принимает на вход разметку на языке HTML и стили для этой разметки на языке CSS, обрабатывает этот код и выдает изображение, которое мы видим в окне браузера. 
* Движок обработки скриптов (script engine), принимающий на вход сценарии на языке JavaScript и выполняет этот код. По-другому это интерпретатор языка JavaScript.

Пример простейшей HTML-страницы. Показать в инструментах разработчика, что это объектная модель (DOM) и отображение строится на основе стилей (если не указаны, то используются стили браузера по умолчанию).

Скрипты могут быть написаны непосредственно в HTML-файле или загружаться из внешнего файла.
Вывод с помощью console.log() идет не на страницу, а в консоль, которую видно в инструментах разработчика. Для чего нужны инструменты разработчика, что с их помощью можно делать.

### Какие версии языка поддерживают браузеры?
Возможности языка зависят от версии интерпретатора. Когда мы работали с PHP, мы устанавливали интерпретатор языка определённой версии (7.4 последний) и могли проверить эту версию. Как это сделать в случае с JavaScript? Какие версии этого языка есть, какими браузерами они поддерживаются?
История JavaScript. Версии ES5, ES6, ES7, ES8. Спецификация языка (стандарт EcmaScript) и комитет TC-39.
Сайт caniuse.com


### Как реализованы основные алгоритмические структуры?
Здесь все стандартно.

### Как работать с переменными и подпрограммами?

#### Как объявлять и инициализировать переменные?
Язык со слабой динамической типизацией.
Переменные объявляются с помощью ключевых слов var, let (ES6) и const (ES6).

#### Как присваивать значения переменным?
Знак равенства.

#### Зависят ли имена переменных от регистра?
Да.

#### В чем разница между var, let и const?
```
//var a = 10;

console.log(a);
```
Здесь будет ошибка, т.е. JavaScript не разрешает обращаться к переменной до того, как она будет объявлена.
```
if (10 > 100) {
   var a = 10;
}

console.log(a);
```
Здесь ошибки не будет, значение переменной a будет undefined. Объявления переменных, сделанные с помощью var, всплывают. Фактически код выполняется так:
```
var a;

if (10 > 100) {
    a = 10;
}

console.log(a);
```
Другой пример:
```
for (var i = 0; i < 3; i++) {
   console.log(i);  // 0, 1, 2
}

console.log(i);  //  3
```

let, в отличие от var, не подвержен всплытию. Поэтому переменные, объявленные с помощью ключевого слова let, будут доступны только в своём блоке кода (внутри фигурных скобок).
```
if (10 > 1) {
   let a = 10;
   console.log(a);  // 10
}

console.log(a);   // ReferenceError
```
Итак, ключевая разница между var и let состоит в том, что переменные, объявленные с помощью let, не подвергаются всплытию, а остаются доступными только там, где были объявлены.
Единственное отличие const от let состоит в том, что переменные, объявленные с помощью const, являются константами, то есть не могут менять своего значения.


#### Как объявлять и вызывать подпрограммы?
В JavaScript можно объявлять функции, причем они являются объектами первого рода. 
Функция может быть динамически создана, скопирована в другую переменную или передана как аргумент другой функции и позже вызвана из совершенно другого места.

Объявлять функцию можно разными способами:
* Function Declaration
```
function sum(a, b) {
   return a + b;
}
```
* Function Expression
```
var sum = function(a, b) {
   return a + b;
}
```
Функции могут быть анонимными:
```
function fn(filter) {
   filter();
}

fn(function() {
   console.log('!!!');
});
```
* Стрелочные функции
```
var sum = (a, b) => {
   return a + b;
};

var result = sum(10, 20);
console.log(result);
```

Самый краткий вариант:
```
var sum = (a, b) => a + b;
```

#### Можно ли вызвать функцию до ее объявления (выше по коду)?
Объявления функций в формате Function Declaration всплывают:
```
var result = sum(2, 3);
console.log(result);

function sum(a, b) {
   return a + b;
}
```
Функции, объявленные с помощью Function Expression, не всплывают – мы не можем вызывать их в программе раньше, чем они будут объявлены и описаны в коде. Здесь будет ошибка:
```
var result = sum(2, 3);
console.log(result);

var sum = function sum(a, b) {
   return a + b;
};
```
Фактически здесь выполняется такой код:
```
var sum;
var result = sum(2, 3);
console.log(result);

sum = function sum(a, b) {
    return a + b;
};
```

#### Поддерживаются ли вложенные подпрограммы?
Да, JavaScript поддерживает вложенные функции. Они могут использоваться для упорядочения и структуризации кода. Что ещё интереснее, вложенная функция может быть возвращена: либо в качестве свойства нового объекта (если внешняя функция создаёт объект с методами), либо сама по себе. И затем может быть использована в любом месте. Не важно где, она всё так же будет иметь доступ к тем же внешним переменным, которые были доступны ей в момент объявления. Это называется замыканием.

#### Как определяются области видимости для переменных?
Область видимости в JavaScript – это набор переменных и функций, которые доступны в определённом месте программы.
В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment.

Объект лексического окружения состоит из двух частей:
1. Environment Record – объект, в котором как свойства хранятся все локальные переменные.
2. Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).
"Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».

Есть глобальная область видимости (лексическое окружение для всего скрипта) и области видимости (лексическое окружение) внутри каждой функции или блока кода внутри фигурных кавычек. При каждом вызове функции для нее создается новое лексическое окружение.

Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.
```
var a = 10;

function fn1(b, c) {
   function fn2(d, e) {
       return a + b + c + d + e;
   }

   return fn2(3,4);
}

fn1(1,2);  // 20
```

Функция получает текущее значение внешних переменных, то есть, их последнее значение.
```
let name = "John";

function sayHi() {
  alert("Hi, " + name);
}

name = "Pete"; // (*)

sayHi(); // Pete
```

Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание. В языке JavaScript все функции изначально являются замыканиями.
Замыканием в JavaScript называется способность функции при вызове получать текущие значения переменных, которые были доступны в блоке кода, где данная функция была объявлена.

```
function makeCounter() {
  let count = 0;

  return function() {
    return count++; // есть доступ к внешней переменной "count"
  };
}

let counter = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1
alert( counter() ); // 2
```

Контрольный вопрос: что будет выведено в консоль?
```
function makeCounter() {
  let count = 0;
  return function() {
    return count++;
  };
}

let counter1 = makeCounter();
let counter2 = makeCounter();

alert( counter1() ); // 0
alert( counter1() ); // 1

alert( counter2() ); // 0 (независимо, т.к. при каждом вызове функции создается новое лексическое окружение)
```

#### Как передавать аргументы в подпрограммы и как возвращать значения из функций?
Строки, числа, логические значения передаются в функцию по значению. Иными словами при передаче значения в функцию, эта функция получает копию данного значения.
Объекты и массивы передаются по ссылке. То есть функция получает сам объект или массив, а не их копию.

#### Какие встроенные функции и стандартные библиотеки есть в языке?


#### Как работать с основными структурами данных (массивы, записи, списки)?


#### Какой стандартный пакетный менеджер используется? Какие полезные внешние библиотеки принято использовать?
Платформа Node.js и пакентый менеджер npm.


### Как взаимодействовать с документом, загруженным в браузер?
DOM позволяет представить HTML-документ в виде иерархии объектов, с которыми можно работать с помощью языка JavaScript.
Основой HTML-документа являются теги (<html>, <head>, <body>, <div> и т. д.). DOM – это представление HTML-документа в виде дерева вложенных друг друга  тегов с их содержимым, которые называются DOM-узлами:
* HTML-теги (как одиночные, так и парные) называются узлами-элементами или просто элементами.
* Текст внутри элементов называется текстовыми узлами.
 Код на языке JavaScript, размещённый внутри HTML-страницы, может обращаться к узлам DOM-дерева, менять их содержимое, создавать новые DOM-узлы и удалять существующие. Также можно задавать обработчики событий, происходящих на узлах DOM-дерева.
Примеры.
Таким образом, для организации интерфейса игры нужно создать верстку для нее: создать HTML-разметку и написать стили для нее. Затем сделать обработчики событий (ввода символа для слова или числа, щелчок мышью на ячейке для сапера и т.д.).

### Какие существуют общепринятые требования к оформлению кода?
ESLinter

###  Можно ли разделять код на отдельные файлы-модули? Как подключать код из этих модулей?
Модульнось в JavaScript более сильная, чем в PHP. В PHP при подключении файла все функции, определенные в нем, попадали в глобальную область видимосит. В JavaScript мы можем определенные функции и переменные скрывать внутри модуля, экспортируя наружу только то, что понадобится в других модулях.
Возможны два варианта:
1. Код разделяется на модули только во время разработки. На страницу подключается единственный файл - результат сборки этих модулей.
Пример с библиотекой jQuery. Делается на базе системы модулей платформы NodeJS, используются сборщики Browserify, Parcel, Webpack. 
2. В ES6 можно разделять JS-код на модули непосредственно в браузере, без использования дополнительных сборщиков. 
Модули могут загружать друг друга и использовать директивы export и import, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого:
* export отмечает переменные и функции, которые должны быть доступны вне текущего модуля.
* import позволяет импортировать функциональность из других модулей.
Отметим, что кроме такого экспорта по умолчанию (ключевое слово default) из модулей можно экспортировать переменные или функции, имеющие имена. Для этого перед определением переменной или функции нужно указать директиву export. Например:
```
export function  sum() {
   //  . . .
}
 
export function  div() {
   //  . . .
}
```
Для импорта в другом скрипте таких функций нужно указывать их имена в фигурных скобках:
```
import { sum, div } from  './model.js';
```
Можно экспортировать что-то через export default ...
На HTML-странице подключается один скрипт (входная точка)
```
<script src="..." type="module">
```

В реальной разработке  модули в браузерах редко используются в «сыром» виде. Обычно, мы объединяем модули вместе, используя специальный инструмент, например Webpack и после выкладываем код на рабочий сервер.

Одно из преимуществ использования сборщика – он предоставляет больший контроль над тем, как модули ищутся, позволяет использовать «голые» модули и многое другое «своё», например CSS/HTML-модули.

Сборщик делает следующее:

* Берёт «основной» модуль, который мы собираемся поместить в <script type="module"> в HTML.
* Анализирует зависимости (импорты, импорты импортов и так далее)
* Собирает один файл со всеми модулями (или несколько файлов, это можно настроить), перезаписывает встроенный import функцией импорта от сборщика, чтобы всё работало. «Специальные» типы модулей, такие как HTML/CSS тоже поддерживаются.
В процессе могут происходить и другие трансформации и оптимизации кода:
* Недостижимый код удаляется.
* Неиспользуемые экспорты удаляются («tree-shaking»).
* Специфические операторы для разработки, такие как console и debugger, удаляются.
* Современный синтаксис JavaScript также может быть трансформирован в предыдущий стандарт, с похожей функциональностью, например, с помощью Babel.
* Полученный файл можно минимизировать (удалить пробелы, заменить названия переменных на более короткие и т.д.).

Если мы используем инструменты сборки, то они объединяют модули вместе в один или несколько файлов, и заменяют import/export на свои вызовы. Поэтому итоговую сборку можно подключать и без атрибута type="module", как обычный скрипт:
