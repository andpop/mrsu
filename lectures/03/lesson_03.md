# Цель - написать консольное приложение на языке PHP, которое работает с базой данный SQLite

#                                                  Настраиваем среду

Программирование во многом связано с настройкой среды, и иногда процесс установки и конфигурирования сложнее, чем написание кода.
В инженерии и программировании есть понятия необходимая сложность и случайная сложность.
Необходимая сложность — это та сложность, от которой никуда не деться, она входит в саму задачу. Например, алгоритмы и вычислительные процессы в программировании. Нельзя заниматься программированием без этих концепций.
Случайная сложность — это та сложность, которая не относится к задаче, но с ней приходится справляться. Настройка систем и инструментов как раз относится к ней. В идеальном мире необходимость подолгу разбираться в программах, утилитах, версиях, зависимостях и прочих инструментах отпадёт, и мы сможем сфокусироваться на необходимой сложности.

Пока мы занимались подготовительной работой:

1. Настроили дистанционную работу с помощью Git и GitHub.
    * Это средство совместной разработки и оценки кода.
    * Дополнительный бонус - надежный бэкап и машина времени, на которой можно вернуться к любой версии.

2. Поработали с встраиваемой СУБД SQLite:
    * Установили SQLite.
    * Научились пользоваться sqlite3 в интерактивном и пакетном режимах.

3. Подготовили среду разработки консольного приложения на PHP
    * Установили PHP для написания CLI-приложений.
    * Установили пакетный менеджер Composer
    * Создали заготовку проекта с помощью Composer.
    * Научились подключать в проект внешние библиотеки (модули, пакеты, зависимости).
    * Научились оформлять свои PHP-проекты в виде пакетов и публиковать их на сайте Packagist.

    * Поняли, для чего нужны пространства имен и как они должны быть связаны с файловой структурой проекта.
    * Научились выполнять автозагрузку файлов (модулей) в PHP-скрипте с помощью Composer.

#                                             Начинаем программировать
Теперь перейдем к программированию.

## Определяемся с общей архитектурой приложения
Мы будем писать приложение в императивном процедурном стиле, поэтому для его разработки пользуемся структурным подходом.  
* Любая программа представляет собой структуру, построенную из трех типов базовых конструкций, которые могут быть вложены друг в друга произвольным образом:
    * **Последовательное исполнение** — однократное выполнение операций в том порядке, в котором они записаны в тексте программы;
    * **Ветвление** — однократное выполнение одной из двух или более операций, в зависимости от выполнения некоторого заданного условия;
    * **Цикл** — многократное исполнение одной и той же операции до тех пор, пока выполняется некоторое заданное условие (условие продолжения цикла).

* Фрагменты программы, которые повторяются или представляют собой логически целостные блоки, могут оформляться в виде **подпрограмм** (функций или процедур).
Подпрограммы можно вызывать в нужных местах основной программы.

* **Разработка программы ведется пошагово, методом «сверху вниз»**.
Сначала пишется текст основной программы, в котором, вместо каждого связного логического фрагмента текста, вставляется вызов подпрограммы, которая будет выполнять этот фрагмент. Вместо настоящих подпрограмм в программу вставляются «заглушки», которые ничего не делают. Полученная программа проверяется и отлаживается. 
После того, как программист убедится, что общая структура программы верна, подпрограммы-заглушки последовательно заменяются на реально работающие, причем разработка каждой подпрограммы ведется тем же методом, что и основной программы. 
Разработка заканчивается тогда, когда не останется ни одной «затычки», которая не была бы удалена. Такая последовательность гарантирует, что на каждом этапе разработки программист одновременно имеет дело с обозримым и понятным ему множеством фрагментов, и может быть уверен, что общая структура всех более высоких уровней программы верна. При сопровождении и внесении изменений в программу выясняется, в какие именно процедуры нужно внести изменения, и они вносятся, не затрагивая части программы, непосредственно не связанные с ними. Это позволяет гарантировать, что при внесении изменений и исправлении ошибок не выйдет из строя какая-то часть программы, находящаяся в данный момент вне зоны внимания программиста.

## Выясняем специфику выбранного языка программирования (PHP)
Считаем, что PHP для нас новый язык (это так и есть, если раньше пользовались им в режиме шаблонизатора для оформления HTML). Чтобы начать программировать, нужно знать ответы на следующие вопросы по основным задачам.

### Как написать и запустить простейший скрипт с выводом в консоль (Hello, world)?
Язык интерпретируемый. Интерактивный (команда `php -a`) и пакетный (`php скрипт`) режимы работы интерпретатора.

### Как реализованы основные алгоритмические структуры?
Здесь все стандартно.

### Как работать с переменными и подпрограммами?

#### Как объявлять и инициализировать переменные?
Специальной команды или директивы типа `var` для объявления переменных нет. Переменная создается в момент первого присвоения ей значения (инициализация переменной).
``` PHP
$a = '1' + 2;   // 3
$b = '1' . 2;   // '12'
```

#### Как присваивать значения переменным?
* Имена переменных начинаются со знака `$`, присваивание символом `=`.
``` PHP
$a = 1;
```
* Язык с динамической типизацией (тип переменной определяется типом ее значения) и слабо типизированный (в выражениях можно смешивать типы, где это возможно автоматически происходит приведение типов).

#### Зависят ли имена переменных от регистра?
Да.

#### Как объявлять и вызывать подпрограммы?
В PHP можно определять функции, которые могут возвращать значение (или не возвращать). Любая программа состоит из функций, вызывающих друг друга.
* Именованные функции:
``` PHP
function f(string $name): string
{
    return "Hello from function, ${name}";
}

echo f('Сергей');
```
* Анонимные функции (замыкания):
``` PHP
$f2 = function (string $name): string
{
    return "Hello from function, ${name}";
};

echo $f2();
```

#### Зависят ли имена функций от регистра?
Нет. Исторически PHP использовался как шаблонизатор для HTML, а теги в HTML регистронезависимы.

#### Можно ли вызвать функцию до ее объявления (выше по коду)?
Да, так как сначала PHP-файл транслируется в байт-код, который потом исполняется.
``` PHP
echo f('Сергей');

function f(string $name): string
{
    return "Hello from function, ${name}";
}
```

#### Поддерживаются ли вложенные подпрограммы?
Формально да, но они не будут локальными, как в Pascal, а станут далее видны для всей программы, но только с того момента, как до их описания дойдет управление. 
``` PHP
function outer()
{
    echo 'Hello from outer';

    function inner()
    {
        echo 'Hello from inner';
    }
}

//inner();   // Call undefined function

outer();
inner();
```

#### Как определяются области видимости для переменных?
Если переменная создается вне функций, то она попадате в **глобальную** область видимости скрипта. Такие переменные доступны во всем скрипте, но не внутри функций (в этом отличие от C, Pascal, JavaScript).
``` PHP
$a = 1;

function f()
{
    echo "a = ${a}";  // undefined variables
}

f();
```
Если внутри функции нужно читать или изменять глобальную переменную, то ее нужно определить внутри функции с ключевым словам `global`:
```PHP
<?php
$a = 1;

function f()
{
    global $a;   // Ссылка на глобальную переменную

    echo $a . PHP_EOL;  // 1

    $a = 2;    // Меняем значение глобальной переменной
}

f();

echo $a . PHP_EOL;   // 2
```
Также можно использовать специальный массив `GLOBALS`:
```PHP
<?php
$a = 1;

function f()
{
    echo $GLOBALS['a'] . PHP_EOL;  // 1

    $GLOBALS['a'] = 2;    // Меняем значение глобальной переменной
}

f();

echo $a . PHP_EOL;   // 2
```
Также есть **статические переменные**, которые определяются внутри функций и сохраняют свои значения между вызовами этих функций.

#### Как передавать аргументы в подпрограммы и как возвращать значения из функций?
По умолчанию аргументы в функции передаются по значению. Чтобы передать аргумент по ссылке, нужно указать & перед именем аргумента.  

####  Можно ли разделять код на отдельные файлы-модули? Как подключать код из этих модулей?
Можно. Подключается через `require_once` или автозагрузку в composer.json (рекомендуется).

#### Какие встроенные функции и стандартные библиотеки есть в языке?
Интерпретатор PHP построен по модульному принципу:
* Базовые конструкции языка (echo, list, require, ...)  реализованы в ядре интерпретатора. 
* Все функции, предопределенные константы и классы реализованы в рамках отдельных модулей - расширений.
Часть расширений входит в состав ядра PHP, часть подключается в виде динамических библиотек, часть нужно загружать через пакетный менеджер.
Посмотреть список доступных расширений можно командой `php -m`.
Исторические особенности PHP: функции именуются разнородно, параметры передаются по-разному. Из-за этого сложно запоминать сигнатуры функций.

#### Как работать с основными структурами данных (массивы, записи, списки)?
Будет достаточно массивов с числовыми индексами и ассоциативных массивов (символьный ключ => значение). На самом деле в PHP все массивы ассоциативные, есть только один тип - `Array`.  Для работы с массивами в PHP есть цикл `foreach` и много стандартных функций.
Если нужны другие структуры данных:
* Расширение php-ds (https://github.com/php-ds/polyfill)
* Пакет Laravel для работы с коллекциями tightenco/collect

#### Какие полезные внешние библиотеки принято использовать?
* https://github.com/phpfunct/funct
* https://github.com/maciejczyzewski/bottomline
* Поиск на Packagist
* Список в репозитории https://github.com/ziadoz/awesome-php

#### Какие существуют общепринятые требования к оформлению кода?
Программирование - это раздел не технических наук, а лингвистики.
Язык программирования - это искусственный язык, на котором мы общаемся с машиной (10%) и с другими программистами (90%).
Мы объясняем другим, что же мы тут хотели сделать. Другой программист, читая код, должен понимать, что вы хотели сделать.

PHP-FIG (PHP Framework Interop Group) — организованная в 2009 году группа разработчиков, основная идея которой находить способы совместной работы, выделяя общие концепции в разработке проектов на PHP.
Группа PHP-FIG поддерживает PSR (PHP Standards Recommendations) — стандарты (рекомендации) для дальнейшего использования.

* Стандарты для PHP: https://www.php-fig.org/
* Стандарты кодирования: PSR-1 (базовый) и PSR-12 (расширенный).
* Автоматическая проверка соответствия оформления стандарту - PHP Code Sniffer (https://github.com/squizlabs/PHP_CodeSniffer)
* Автоматическое форматирование - PHP Coding Standard Fixer (https://github.com/FriendsOfPHP/PHP-CS-Fixer)
* Руководство по чистому коду в PHP на русском языке: https://github.com/peter-gribanov/clean-code-php


