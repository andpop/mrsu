Основная задача - переписать UI. Используем чистый JavaScript, UI основан на DOM и обработке событий. 
Далее мы будем подключать базу данных IndexedDB, она работает асинхронно, тоже нужно будет работать с событиями. 
Поэтому сначала поговорим о браузерных событиях.


## Браузерные события
### Виды событий
События от мыши, клавиатуры, от элементов управления (отправка формы), от документа (DOMContentLoaded), от окна браузера (прокрутка).

### Обработчики событий. Способы задания
Для задания обработчика нужно сначала идентифицировать элемент. Способы (в том числе автоматически создаваемая глобальная переменная).

В обработчик события передается объект с параметрами события
Есть три способа назначения обработчиков событий:

Атрибут HTML: onclick="...".
DOM-свойство: elem.onclick = function.
Специальные методы: elem.addEventListener(event, handler[, phase]) для добавления, removeEventListener для удаления.
HTML-атрибуты используются редко потому, что JavaScript в HTML-теге выглядит немного странно. К тому же много кода там не напишешь.

DOM-свойства вполне можно использовать, но мы не можем назначить больше одного обработчика на один тип события. Во многих случаях с этим ограничением можно мириться.

Последний способ самый гибкий, однако нужно писать больше всего кода. Есть несколько типов событий, которые работают только через него, к примеру transitionend и DOMContentLoaded. Также addEventListener поддерживает объекты в качестве обработчиков событий. В этом случае вызывается метод объекта handleEvent.

Не важно, как вы назначаете обработчик – он получает объект события первым аргументом. Этот объект содержит подробности о том, что произошло.

### Делегирование событий
Всплытие событий
Принцип всплытия очень простой.  Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.

event.target и event.currentTarget
Всегда можно узнать, на каком конкретно элементе произошло событие.

Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через event.target.

Отличия от this (=event.currentTarget):

event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.
event.currentTarget (он равен this) – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.

Пример с таблицей (один обработчик, определение координат ячейки, по которой кликнули)

* data-атрибуты (?) Пример с декларативным объявлением счетчика.
* console.log и console.dir
* document.querySelectorAll() даёт объект NodeList. Это не массив (но у него есть метод forEach). Можно преобразовать к массиву, после чего применять любые методы для массива:
```
let elems = document.querySelectorAll('td');

let a = [...elems];
let b = Array.from(elems);
```

