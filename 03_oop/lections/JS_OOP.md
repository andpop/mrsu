В JavaScript есть объекты, но они не похожи на объекты, которые мы привыкли видеть в объектно-ориентированных языках программирования типа Java или C++. Все свойства объекта в JavaScript открыты, а сами объекты не принадлежат никакому классу, кроме Object. Не понятно, как реализовать методы, классы и наследование.
Но все это можно устроить в JavaScript, и в этой главе показано, как именно.  В современных версиях JavaScript имеется синтаксис для объявления классов, внешне очень похожих на классы в Java, хотя внутренний механизм совершенно иной. Необходимо понимать, что творится под капотом. Поэтому я сначала покажу, как объявлять методы и функции-конструкторы вручную, а потом мы посмотрим, как эти конструкции отображаются на синтаксис классов.

## Объекты-литералы
Можно работать с объектами, не объявляя предварительно классы. Метод - обычное свойство, значением которого является функция. Краткий синтаксис для метода. Слово this.

## Прототипы
Прототип - внутреннее свойство (слот) объекта. [[Prototype]] указывает на другой объект. Механизм поиска в прототипах (при чтении) - для всех свойств. При записи новое свойство добавляется в сам объект, прототип не меняется.

## Конструкторы
Конструкторы. В традиционных языках, основанных на классах, конструктор - это специальный метод, присоединенный к классу. Он автоматически вызывается при создании экземпляра класса оператором new.
В JS конструкторы - это обычные функции, которые вызываются с указанием оператора new перед ними. При этом:
1. Создается новый (пустой) объект.
2. Вызывается функция-конструктор. При этом созданный объект доступен по ссылке this.
3.  У каждой функции в JS есть свойство prototype, значением которого является объект. Внутреннее свойство [[Prototype]] созданного объекта начинает указывать на специальный объект, прикрепленный к функции-конструктору (функция - это объект, поэтому она может иметь свойства) через свойство prototype. То есть устанавливается связь двух объектов.
4. Если функция не возвращает свой альтернативный объект, то автоматически возвращается сконструированный объект. В функци-конструкторе return не должно быть.

Итак, JS создает связь между двумя объектами, благодяря которой один объект может делегировать обращения к свойствам/функциям другому объекту. Термин "делегирование" точнее описывает механизм связываения объектов в JS.

Можно сказать, что new захватывает обычную функцию и вызывает ее способом, который конструирует объект.

## Синтаксис классов

## Геттеры и сеттеры

## Приватные поля и методы

## Статические поля и методы
На внутреннем уровне статический метод является свойством конструктора.

## Наследование. Подклассы и суперкласс
Наследование реализуется цепочкой прототипов.

## Переопределение методов. Полиморфизм
В JS полиморфизм является простым следствием поиска в цепочке прототипов.



-----------------------------------------------------------------------
В языке JavaScript вызываемая функция будет иметь собственный контекст лишь в трёх случаях:
1. Функция вызывается в виде метода объекта, то есть через точку или квадратные скобки (например, a.f() или a['f']()).
2. Для вызова функции используется метод bind, call или apply.
3. Функция вызывается с помощью ключевого слова new.

В остальных случаях контекст сбрасывается на внешний блок.


Пять золотых правил безопасного программирования на JavaScript:
1. При объявлении переменных употребляйте ключевые слова let или const, а не var.
2. Пользуйтесь строгим режимом.
3. Обращайте внимание на типы и избегайте автоматического преобразования типов.
4. Разберитесь, что такое прототипы, но для работы с классами, конструкторами и методами применяйте современный синтаксис.
5. Не используйте ключевое слово this вне конструкторов и методов. Чтобы избежать неприятностей, не используйте this внутри функций, определенных с помощью ключевого слова function.  Безопасно использовать this в методах и конструкторах, а также в стрелочных функциях, определенных внутри методов и конструкторов.



