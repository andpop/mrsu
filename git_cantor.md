##           Конфигурация
### 07. Игнорирование: .gitignore
Проверка игнорирования пути (находит строку в .gitignore, задающее исключение для отслеживания git)
`git check-ignore -v путь`

##           Основы
### 02. Git и права на файлы
Права на файлы в репозитории
644 - если файл неисполняемый
755 - если файл исполняемый
Если коммитить под Windows, то права всегда будут 644. Можно принудительно поставить файлу атрибут “исполняемый”.
`git update-index --chmod=+x index.html`

### 06. Зачем нужен индекс?
Добавление в индекс (stage) фрагментов из файла:
`git add -p index.html`

### 07. Коммиты без add
Коммит конкретных файлов без предварительного добавления их в индекс (только для отслеживаемых файлов)
`git commit -m ‘Test’ index.html`

### 08. Удаление и переименование файлов
Удаление из рабочего каталога и добавление этого изменения в индекс
`git rm -r src`   // -r для каталога
 
Удаление из индекса, но оставить в рабочем каталоге
`git rm -r --cached src`

Переименование файла в рабочем каталоге и добавление этого изменения в индекс
`git mv old.txt new.txt`

##           Ветки
### 02. Создание и переключение
Просмотр веток с идентификаторами коммитов
`git branch -v`

HEAD обычно хранит ссылку на текущую ветку. Вершина ветки = последний коммит в ветке.
`git checkout -b new_branch`  = `git branch new_branch` + `git checkout new_branch`

### Урок 03
Принудительное переключение на другую ветку с потерей всех незакоммиченных изменений
`git checkout -f another_branch`

Отмена всех незакоммиченных изменений в текущей ветке 
`git checkout -f HEAD` или `git checkout -f`
`git clean -fd`  = то же самое?

Сохранить изменения
`git stash`
Вернуть изменения
`git stash pop`

### 04. Создание ветки из последних коммитов, передвижение веток
Создание ветки с указанием конкретного коммита. Если такая ветка уже есть, то произойдет переключение на нее, вершиной станет указанный коммит.
`git branch -f master 51c4`   или  `git checkout -B master 51c4`
Вместо идентификатора коммита можно указывать имя ветки.

### 05. Состояние отделенной HEAD
Переход на любой коммит (без ветки)
`git checkout 1913`

### 06. Восстановление предыдущих версий файлов
Восстановление конкретных файлов из предыдущего коммита. Файл копируется в рабочий каталог и в индекс.
`git checkout 54a4 index.html`

Восстановление файла из текущего коммита в рабочий каталог и в индекс.
`git checkout HEAD index.html`

Восстановление файла из индекса в рабочий каталог
`git checkout index.html`

Двойной дефис в команде указывает на то, что после него идут пути к файлам. 
Например, чтобы восстановить файл master: `git checkout -- master` или `git checkout HEAD -- master`

### 07. Просмотр истории и старых версий, ~ и :/
Просмотр подробной информации о коммите
`git show 2702`

~ соответствует родительскому коммиту
Просмотр информации о коммите, отстоящем от текущего на три:
`git show HEAD~~~` или `git show HEAD~3`

Вместо HEAD можно писать @ (в PowerShell придется брать в кавычки)

Просмотр файла из предыдущего коммита (без его восстановления в рабочий каталог)
`git show HEAD~:index.html`

Просмотр файла из индекса
`git show :some.txt`

Показать коммит, в описании которого содержится слово (можно искать и по регулярке)
`git show :/some_word`
Ищется самый новый коммит с таким словом в описании (не обязательно в текущей ветке)

### 08. Слияние перемоткой
Команда `git merge` перед объединением записывает предыдущий HEAD в файл .git/ORIG_HEAD. Поэтому можно вернуться на предыдущий HEAD
`git branch -f master ORIG_HEAD`
`git checkout master`

### 09. Удаление веток
Удаление ветки (т.е. удаление указателя на коммит). Удаляет только ветку, объединенную с текущей
`git branch -d fix`

Принудительное удаление неслитой ветки (коммиты из нее какое-то время сохраняются, затем очистятся)
`git branch -D some_branch`

### 10. Лог ссылок: reflog
При любых операциях, приводящих к изменению ссылок, Git записывает эти ссылки в файл в каталоге .git/logs/.
Например, для ссылки HEAD в файле .git/logs/HEAD

`git reflog some_branch`
`git feflog`   // для HEAD

git reflog - это алиас для `git log --oneline -g`. Ключ -g переводит git log на отображение записей из reflog.

Просмотр лога с датами записей
`git reflog --date=iso`

Переход на предыдущую ветку, с которой мы ушли на master
`git checkout @{-1}`
Также можно кратко `git checkout -`

### 11. Сборка мусора
Удаление недостижимых коммитов и оптимизация базы Git
`git gc`

Список всех недостижимых коммитов
`git fsck --unreachable`

Очистка всех reflog
`git reflog expire --expire=now --all`

Очистка всех недостижимых коммитов (независимо от их даты)
`git gc --prune=now`

##           Теги
### 01. Теги, основные действия с тегами
Тег = ссылка на коммит. Он никуда не перемещается и всегда указывает на один и тот же коммит.
`git tag v.1.0.0 HEAD`

Можно использовать в других командахх
`git show --quiet v.1.0.0`

Какие релизы содержат определенный коммит?
`git tag --contains 54a4`

Вывод списка тегов вместе с сообщениями коммитов
`git tag -n`

Удаление тегов
`git tag -d v1.0.0`

Создание тега с аннотоацией
`git tag -a -m 'Version 1.0.1' v.1.0.1 1913`

### 02. Использование тегов для экспорта с describe, archive
Вывод информации о теге по коммиту
`git describe 54a4`

Архив файлов (zip) из содержимого репозитория на момент определенного коммита
`git archive -o /tmp/v1.1.0-2-g2c11.zip HEAD`


##           Reset
### 01. Жесткий reset, отмена коммита
`git reset --hard 2fad`

Предыдущий коммит, на котором мы находились до жесткого reset, сохраняется в файла ORIG_HEAD
Возврат к нему
`git reset --hard ORIG_HEAD`

Можно удалить все незакоммиченные изменения.
`git reset --hard HEAD`

### 02. Мягкий reset, замена и объединение коммитов
`git reset --soft` переносит указатель коммита, но оставляет рабочий каталог и индекс

Взять для нового коммита информацию об авторе и описание из уже существующего коммита
`git commit -c ORIG_HEAD`

Поменять можно только последние коммиты.
Нельзя изменить коммит в середине списка, не трогая других, идущих за ним.

### 03. Правка последнего коммита: commit --amend
Исправление последнего коммита
`git commit --amend` = `git reset --soft HEAD~` + `git commit -c ORIG_HEAD`

### 04. Смешанный reset, отмена индексации
Рабочий каталог остается, индекс заменяется (режим --mixed используется в git reset по умолчанию)

Можно сбрасывать в индексе отдельные файлы
`git reset index.html`

Можно взять файл в индекс из другого коммита
`git reset 54a4 index.html`
Используется очень редко, так как обычно нужно изменить файл не только в индексе, но и в рабочем каталоге.
Это делает команда `git checkout 54a4 index.html`

### 05. Жесткий reset с сохранением изменений: --keep
Сохраняются незакоммиченные изменения в тех файлах, которые не менялись между коммитами.

Посмотреть, какие файлы изменялись в текущем коммите (в сравнении с предыдущим коммитом)
`git diff --name-only HEAD~`

### 06. Особый reset для отмены слияний: --merge
Похож на `git reset --keep`, но удаляет изменения в индексе.

### 07. Виды reset - таблица в документации
Внизу помощи `git help reset` есть таблица, поясняющая разные режимы reset.



##           Очистка проекта от изменений
### 01. Очистка проекта от изменений
Очистка рабочего каталога от неотслеживаемых файлов
`git clean -fd`

Дополнительно очистить файлы, игнорируемые через .gitignore
`git clean -fxd`


##           Просмотр
### 01. Сравнение коммитов, веток и не только: git diff
`git diff commit_1 commit_2`

Сравнение рабочего каталога с индексом
`git diff`

Сравнение рабочего каталога с коммитом
`git diff HEAD`

Эти команды игнорируют неотслеживаемые файлы

Сравнение индекса с коммитом
`git diff --cached`

Можно указывать имена конкретных файлов для проверки
`git diff index.html`

Перед путями можно ставить --
`git diff -- index.html`

Просмотр информации перед коммитом
`git diff -v`

Если нужны только имена измененных файлов
`git diff --name-only master feature`

Сравнение отдельных файлов из разных коммитов
`git diff commit1:path1 commit2:path2`

Сравнение двух файлов на диске (независимо от Git-репозитория)
`git diff --no-index path1 path2`

### 02. Сравнение по словам, драйвер diff
`git diff --word-diff`
`git diff --word-diff=color` = `git diff --color-words`

### 04. Вывод истории: git log, форматирование коммитов
По умолчанию git log в обратном хронологическом порядке выводит информацию о коммитах, достижимых из HEAD.
Формат по умолчанию:
`git log --pretty=medium`

Краткий формат
`git log --pretty=oneline --abbrev-commit`
`git log --oneline`

История коммитов с описанием изменений
`git log --patch` или `git log -p`

### 05. Диапазоны коммитов для gil log и не только
Вывод коммитов, достижимых из указанных веток, в псевдографике
`git log master feature --graph`

Коммиты, достижимые из feature и недостижимые из master
`git log feature ^master`
То же самое (коммиты ветки feature с момента отхождения от ветки master)
`git log master..feature`
`git log HEAD..feature`
`git log ..feature`

### 06. Вывод git log коммитов, меняющих определенный файл
Вывод коммитов, в которых менялся файл index.html
`git log index.html`

Посмотреть конкретные различия в коммитах, т.е. как менялся файл в коммитах
`git log -p index.html`



##           Слияние
### 01. Истинное слияние и разрешение конфликтов в git merge
При слиянии master с feature произошел конфликт в файле index.html. Если нужно взять версию файла с master, то 
`git checkout --ours index.html`
Если нужно взять версию index.html из feature, то 
`git checkout --theirs index.html`
Вернуть версию, где указаны конфликутющие изменения
`git checkout --merge index.html`

Отказ от слияния (жесткий ресет)
`git reset --hard`

`git merge --abort`

Получение конфликтного файла с дополнительной информацией о базовом состоянии файла (в общем коммите, до разделения веток)
`git checkout --conflict=diff3 --merge index.html`
Будет ours, theirs и base

Продолжить слияние после исправления конфликтов
`git merge --continue`

